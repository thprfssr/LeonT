0: Overview

I want to calculate the constant e to one trillion digits. To do that, I plan on
having multiple computers working together in order to solve the problem.
Comp#1: You sum up the term #193220 to #203230949
...
Comp#k: Compile the results from these computers, and give me a decimal expansion.
..

To do that, I assume we need a hierarchy of director computers, to determine which
tasks to divide between which computers. We should also have a director of
directors. Also, if a director goes offline, the group of computers it used to
direct should decide which one of themselves will be the new director.

Oh, we should divide our computers into groups, each one with one director.

I don't wanna do this across the Internet, since there are security risk
associated with data transmission. I don't wanna mess up my friends' computers.
What I wanna do is to use a local network of computers.

If I really wanna do this across the Internet, I need to learn more about
Internet security.

1: Algorithms

1.1: Taylor Series

Here is the formula to compute the digits:
e = \sum_{k=0}^n 1/k!
  = 1/n! * \sum_{k=0}^n n! / k!
  = 1/n! * \sum_{k=0}^n \prod_{h=k+1}^n h

*This is wrong. Try looking at the terms more concretely.

1.2: Lagrange Error Bound

Using the Lagrange error bound, we get
R_n(x) = f^(n+1)(c)/(n+1)! * (x-a)^(n+1), for a is the center, for c between x and a. n is the nth taylor polynomial.
Now, we let f(x)=e^x,  x=1, and a=0. Thus,
R_n(1) = e^c/(n+1)! <= e/(n+1)!
We want our error R to be R < 10^(-10^12), so
e/(n+1)! < 10^(-10^12)
\implies
e * 10^trillion < (n+1)!
Which implies

1 + 10^12 * ln(10) < \sum_{k=0}^{n+1} ln(k)

Now, in the summatory in the left side, it's not bad to have one extra term, by letting m = n + 1, and making
m the actual number of terms we use. So this formula simplifies to
1 + 10^12 * ln(10) < \sum_{k=0}^n ln(k).

If we solve that inequality, we obtain the number n of terms.

Now, in order to actually write a program that can solve for the number n of terms, we need to
take into account the accumulated error of the floating point representations.
We can use GMP Floating Points in order to have better precision.

Now, our final result for the summatory will be in the order of magnitude of 10^12.
Let's round that up to 10^13.
Therefore, in order to maintain the integer digits unharmed, we would like a precision of 10^26.
If we take the log2, we get around 86.370, but let's round that up to 128.
Therefore, we would like to floating points of precision of 128 bits at least.
But it wouldn't hurt to round up even further to 256 bits.

We must use gmpfr because they have natural logarithms.

Also, Just in case one of the digits further down changes one of the digits further up (e.g. 3999 --> 4000),
we should add, say, 32 digits in addition to the required digits. That's a long and unlikely trail of 9's!

Ok, so I just tested the program that uses MPFR, and it's super slow!
It will finish in 28 hours, I estimate.
Therefore, we will have to take another approach.
Okay, so for double precision in C, the mantissa is 52 bits. That means that
for every term, there is a +/- 2^(-52) * 2^d error, where d is the exponent.
the error.

1.3 Number of Terms

We want to solve for the smallest integer which satisfies:
1 + D * ln(10) < \sum_{k=1)^n ln(k).
Consider the following inequality:
ceil(1 + D * ln(10)) < \sum_{k=1}^m floor(ln(k)).
Then, m < n, since a larger number of terms would need to be summed. This inequality
can be solved easily, rapidly, and precisely by using a big integer library. Once we
solve it, we obtain m, which is an upper bound for n.

Now, a double precision floating point has a 52-bit mantissa. The mantissa of the
output of the log function in the C math library depends on the size of the integer
part of the output. For example,
log(10^11) = 11 * log(10) = 25.328436... < 26 = 0b11010,
which has 5 bits, so there are 52 - 5 = 48 bits left for the fractional part. That
means that the error R satisfies R < 2^(-48).

So once we find m, we find B = ceil(log2(m)), which will be the bitcount for the
integer part of m, and we assume that each term in the first inequality has error
2^(B-52). Multiply by the amount of terms, and we obtain R = m * 2^(B-52). Notice
that this is more than the actual error, which is good; we want to overestimate the
error.

Now, it should be pointed out that when D = 10^12, which accounts for the first
trillion decimal digits of e, m is less than 10^11. If we let m = 10^11, then we get
log(10^11) < 26 = 0b11010, as we saw earlier. Then, we just repeat the same
procedure and we get R < 10^11 * 2^(-48) = 10^(-4) * 3.5527..., which means that the
error of the summatory in the first inequality is negligible.

If we are really worried about error, it suffices to just apply the floor of the
whole summatory to force it to add more terms according to the error. Moreover,
since the logarithm grows very slowly, it will take a LONG time for the error for
each individual term to grow larger than just a fractional part. Thus, just taking
the ceiling of the entire summatory suffices for all practical purposes (say, for
computing the first QUINTILLION digits of e). So in the end, the equation we really
care about is the following:
ceil(1 + D * ln(10)) < floor(\sum_{k=1}^n ln(k)).

1.4: Main Loop

Our program will have two main parts. The first part is to compute a rational number
which approximates exp(1) to the desired number of digits. The second part will
compute another rational number which will approximate exp(-1). Finally, it will
compare the digits of both; if the digits are all the same, we have success. Else,
we have to go back to the planning board.

For each of the two parts, our program will first compute a numerator, then a
denominator, and finally, it will divide these two integers to obtain the digits.
In order to compute the numerator for the exp(1) part, assuming that n is the
required number of terms, the pseudocode is as follows:

int getNumerator(int n)
{
	int sum = 0;
	int product = 1;

	for(int i = 0; i < n; i++)
	{
		for(int j = n; j >= n - i; j++)
		{
			product *= j;
		}

		sum += product;
	}

	sum += 1 + n!;

	return sum;
}

This code is absolutely correct; double check it, if you don't trust me.

Now, let's analyze the code. In the loops, we're essentially computing this:
(n) +
(n)(n-1) +
(n)(n-1)(n-2) +
... +
(n)(n-1)(n-2)...(3) +
(n)(n-1)(n-2)...(3)(2) +
(n)(n-1)(n-2)...(3)(2)(1)

So we need to define a function prod(int a, int b) which takes arguments a < b,
and is defined as follows:

int prod(int a, int b)
{
	int product = 1;

	for(int i = a; i <= b; i++)
	{
		product *= i;
	}

	return product;
}

Back to our getNumerator function, notice that as the loop progresses, we have
to multiply bigger and bigger numbers. I intentionally made it so that the easy
computations are the ones which get done first, so that as the loop progresses,
we get closer and closer to the factorial of n.

Actually, we don't have to sum these terms in order; we can just declare a task
which consists of adding a given term (or several of them) to the main
numerator file.

1.5: Splitting Productories into Tasks

Now, we must find a way to split the prod(a,b) into tasks, because we're
dealing with large numbers here. What I propose is to compute the bitcount for
prod(k,n), where we let k vary. Once we find the k closest to n for which the
bitcount is less than 16 MiB (2^24 B), we declare that as a task. Actually, we
don't wanna compute the actual bitcount of the product, since that requires
knowing the product in advance. What we wanna do is to compute a bitcount upper
bound for a productory, which is easier to implement. Namely, the bitcount of
an integer n is simply the floor of the base 2 logarithm. Therefore, we have:

bitcountUpperBound( (a)(a+1)(a+2)...(b-2)(b-1)(b) )
= floor( ceil(log2(a)) + ceil(log2(a+1)) + ... + ceil(log2(b)) );

Notice that we want to save some results on disk so that we don't have to
compute them all over again. This complicates our task division. Actually,
before proceeding any further, we have to master the art of performing
arithmetic on integers saved throughout multiple files.

1.6: Arithmetic on Integers Saved throughout Multiple Files

1.6.1: Addition

We will divide up our integers into files of exactly 16MiB (the most
significant bits will be filled with zeros as needed). For each file, we can
copy it from storage to RAM for use. We will only work on one file at a time to
ensure that we don't blow up RAM. For each file, we will create an MPZ object
to work with.

In order to refer to an integer partitioned into several files, we will create
a plain text file, called an index, which will contain the number of files
associated with the integer, and the name for each file (which will just be the
hash of the contents).

1.6.2: Multiplication

Multiplication is just addition with bitshifting. Example:

A * 1101 = A * 1000 + A * 100 + A * 1;

We will implement multiplication in two ways: The Addition way, and the Lattice
way. Whichever way is faster is the one that we will use.

2: Distributed Computing

We might want to have multiple computers work together in order to compute the factorials.
Also, we might want to save the factorials somewhere in the network (at multiple places,
in case one or more computers go offline) so that we will not have to recalculate it.

The network should be such that if a node goes offline, the network should not be severely affected.
And that if a node goes online, she is immediately assigned a group and a task to work with.

RESOURCES SHOULD NOT BE LEFT IDLE

Also, a computer should be able to work offline. Even if it works on the same problem as another computer online,
that is good because it means the result is doubly verified.

A computer shoud work offline, save the results locally, and send them on the network once it goes back online.

3: Task Management

Now, we should divide this into small tasks. Then we would write onto disk the partial results of
multiplications in files of size 4MiB - 8MiB. We do this in order to not use all of RAM.
Now, we will keep the partial sum of the terms on disk as well. We will have to split it up into
several files. We should indicate somewhere the number of terms added.

So regarding the partition of tasks: 4MiB-8MiB files which contain for example: productory from 2240992 to 23093009329.
The important thing is that the file is in the range 4-8MiB.

The program should also return where it left off in the event that the OS requests to end it.

The program should also have a status file, where it outputs its status.
The status file should be read and displayed on request.

Also, the program should have a log file. In it, we make sure which processes start, which processes end properly,
which processes are interrupted, etc. That way, we can know which files might be corrupted due to an interruption.

Moreover, there should be a Task Queue file.

More on Tasks:

Process to compute Prod(a,b) (multiply every number between a and b inclusive)
- Start from a, and then compute the binary digits of the partial products.
Once the binary digits reach a certain threshold at Prod(a,k), append
Prod(a,k) to the Task Queue.
-Repeat, but this time starting from k+1.
-Keep going until all of Prod(a,b) is covered.

*The Task Manager portion of the program should assign some tasks to every node, and the nodes
should confirm that they have accepted the task.

Once Prod(a,b) is partitioned, and the partial products are computed, we need a way to
multiply all of those together and store it in multiple files. This is a proposal
on how to store it between multiple files:
- Index file: tells what number is stored in the files, how many files is it stored in, and
which digits each file contains.
- Data file #1: contains digits
...
- Data file #n: contains digits.

All these files will belong in one folder. This is how the files are called:
FOLDER: .name/ (something like .39af200)
- index.txt
- 0.data
- 1.data
...
- n.data

**The index file should be the last one being written, in order to confirm that everything went alright without interruptions.

Concerning Task Management
If we want to assign a task to a node, we do this in the log file

Master-Node: assigning Task tatata to Slave-Node#k
Slave-Node#k: Task tatata received

The Task Manager should take into account the Latency and the Bandwidth between the Master and each Slave.
If the connection is slow, then it assigns MORE tasks to the slave. That way, the slave spends less time
communicating with the Master.
If the connection is fast, then less tasks are assigned to the slave, since it wouldn't be much of a setback to
comunicate with the master, so the slave can be reassigned work very quickly should the need arise.
Note that we only care about the RELATIVE speed (Ah, this node is slower than the rest, or this one is faster than the rest)
and NOT the absolute speed.
Actually, absolute speed should also be coonsidered. If each and every connection is slow, then each
node would need to be more autonomous.

In order for the master to assess the speed of a connection, he can send a small packet of data to the slave,
and the slave would immediately respond. That way, the master can assess the connection spped.

Moreover, each Slave should immediately accept an order from the master for cancelation of an impending task,
and also a task which is already running.

Also, when the slave outputs to the log file that it completed a task, he should also indicate the time it took him
to complete that task. That way, the Master can assess its average speed. The slave will indicate
the time of starting the task, and the time of completing the task.
This is also a way for us to assess (at the end of all the computations) how much time was spent doing what.

Also, the slave should indicate if the task failed.

In the case where the Master looses connection with a slave, or a slave does not respond within a reasonable period of time,
say one or two minutes, the Master should see if he is ok. THe master should request the slave to recite all of his
impending tasks. If he forgot them, well, he forgot them, and the master reassigns the lost tasks to other nodes.
This means that every so often, the slaves should indicate to the master that everything is ok for them, say
every 10, 30, 60 minutes or something.

If a slave goes offline temporarily, he should continue working on the taskks appointed to him. Every node should be appointed
lots of tasks to do in the case that they go offline and they finish their immediate tasks. So we have the
present tasks queue, and the offline tasks queue. When the slave goes back online, he should report to the master everything
he did (if he did anything at all). If the master finds that the slave did all his present tasks and several of the offline tasks,
great! If the slave crashed and forgot all his tasks, that means that the master will now begin to distribute all the tasks appointed to him
to other nodes, and perform a system check on the node. If the system is alright, then assign him new tasks. If not, put that in
the status file.
The offline queues for each node should be updated every so often, based on whether they are completed.
Each node should have a MINIMUM number of offline tasks, but not necessarily a maximum.

If a slave goes offline, and the master immediately needs one of the tasks appointed to the slave to be completed,
then the master will reassign the needed tasks to other online computers, regardless of whether or not the slabve
is currently working on it while offline.

If the offline slave comes back online with his task completed, but other online slaves already did it, great! that serves as
a confirmation.
IF two nodes perform the same task, they should compare their results. If their results match, put it in the log file.
If the results DONT match, put it in the log file, and also write it in the status file.

Keep a track record of offline-offlinings for each slave to assess their reliability.

Each process should be able to "checkpoint". That means that it  creates an image of itself at that instant,
so if it is killed, it could simply resume from where it left off.
####

Suppose we have a Prod(a,b) partitioned into many partial products over several files. How will we
multiply all those numbers?
First off, each dump of digits should have a bigint MANTISSA, and an exponent n, so that the number represented
would be MANTISSA * 2^n. That way, we don't have to store a lot of zeroes in disk.

With that in mind, here is what we can do: Let's say we want to multiply A and B, here is what we do:
Split the digits of A somewhere around the middle into the digits A_1 and the digits A_2, and the same with B,
such that the following conditions hold:
1) A_1 * 2^k_A + A_2 = A, and the same for B, where k is where the split was made
2) The filesize for A_c * B_d is within a reasonable range.
Imagine with this latice:
____|A_1|A_2|
|B_1|___|___|
|B_2|___|___|

The filesize for each one of the four resulting squares should be within our acceptable range (4MiB-8MiB or something).
Actually, we don't split it exactly in half: we split however many times we need.
Finally, sum up all the resulting files (this is easier).

Note that even the final multiplication of two giant multi-file integers can be split into tasks of multiplying smaller integers.
Actually, in order to do this, let's forget about a minimum file size, and only focus on a maximum file size. Let this be 16MiB, 2^34 Byytes.

3.1: Task Management Requirements

The part of the program which will take care of tasks should do the following:
-Compute what tasks will need to be done
-Figure out which tasks depend on which other tasks
-Track which tasks have been completed

4: Logging

Our program will need to keep one or more log files. To do that, we can use
syslog. How many log files will we need? I think one suffices. We would use this log
file in order to keep track of which nodes enter and leave the network, which nodes
are unresponsive, which tasks are declared by the master, which tasks are assigned
to which nodes, which tasks are started being solved by which nodes, which tasks are
completed by which nodes, which tasks have been verified by which nodes, which tasks were interrupted or lost (determined by the
master), etc. Therefore, this is a general log file.

This log file must NEVER be deleted! Else, we would have to start over in
computing e. Our data from previous calculations would be intact, but we wouldn't
know what to do with it.

4.1: Log file
The master node should be the only node writing into the log file. The rest of
the nodes must pass their messages to the master in  order for him to write.
We do this in order to eliminate the possibility of having multiple nodes write
to the log file at the same time, possibly corrupting it.

5: Data Storage

We will dump all our data into binary blobs less than 2^24 Bytes, or 16MiB.
The name of each file will be the hash of its contents. That way, we can ensure
that the data in the file is not accidentally altered or corrupted. Now, the
interpretation of the data, and what to do with it, that is up to the master
node to figure out.

In the table of tasks, where we put information about each task (e.g. whether
it was completed, verified, assigned, if it was supposedly completed but there
are missing files, who completed it, etc.), we should also write a list of
data files associated with the task.

Each integer's files will be stored in a folder. The integer's data will be
stored in files whose name is the hash of its contents. In the folder, there
will be a special file called "index" which is structured as follows:
[number of files for the integer, excluding the index]
[name of datafile #1 (least significant)]
[name of datafile #2]
...
[name of datafile #k]
[hash of concatenation of filenames]

In the end, we will have the hash of the concatenation of filenames in order
to prove that everything went well and with no interruptions. If that line is
not present, then we know that something went wrong.
